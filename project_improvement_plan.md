# План улучшения проекта (Next.js 14 + NextAuth + Prisma + OpenAI)

Дата: 2026-02-03

Цель: поднять качество MVP до уровня «стабильно в проде», снизить расходы на токены, улучшить безопасность и предсказуемость генераций.

---

## 0) Принципы изменений

- **Единый источник правды для текста**: что показываем пользователю = то, что сохраняем в БД.
- **Промпт-пайплайн детерминированный**: одинаковый вход → одинаковый ключ кэша/квоты/логики.
- **System = правила**, **User = данные и конкретная задача**.
- Логи не должны содержать чувствительный пользовательский контент.

---

## Этап 1 — Срочные исправления (блокеры качества)

### 1.1 Разнести system/user и убрать дублирование sourceContent
**Зачем:** сейчас источник контента попадает в запрос дважды, правила/контент смешаны, растут токены и шанс «поплывшего» поведения.

**Задачи:**
- В `openai-client.ts` сделать явный интерфейс:
  - `system: string` (короткие правила и ограничения)
  - `user: string` (задача + sourceContent)
- В `ai.ts`:
  - не передавать `sourceContent` отдельно, если он уже встроен в `user`.
  - вынести общий system для всех платформ (тон, безопасность, запрет на PII, формат).

**Готовый критерий:** один источник контента в запросе, прозрачная схема формирования сообщений.

---

### 1.2 Исправить интеграцию Brand Voice
**Проблема:** сейчас вставка часто уезжает в конец (плейсхолдера уже нет после `formatPrompt`).

**Задачи:**
- В шаблоны промптов добавить `{brandVoice}`.
- Вставлять brand voice *в нужное место* до инструкций платформы (или строго по маркеру).
- Хранить brand voice как инструкцию (bullet rules), без воды.

**Готовый критерий:** brand voice всегда вставляется в стабильную точку шаблона.

---

### 1.3 Унифицировать sanitize + validate + return
**Проблема:** в БД сохраняется `sanitizedContent`, а клиенту возвращается сырой текст.

**Задачи:**
- Ввести одну функцию-пайплайн, например `finalizeGeneratedContent()`:
  1) validate
  2) sanitize
  3) return sanitized
- Использовать её в:
  - `generateForPlatforms`
  - `regenerateForPlatform`
  - любых будущих генераторах

**Готовый критерий:** UI и БД получают одну и ту же финальную строку.

---

### 1.4 Привести генерацию результатов к `Promise.all`
**Проблема:** `results.push()` внутри async map → хаотичный порядок и сложнее дебажить.

**Задачи:**
- Переписать на `Promise.all(platforms.map(...))`.
- Нормализовать порядок результатов по входному `platforms`.

---

## Этап 2 — Экономия токенов и кэширование

### 2.1 Сделать детерминированные cacheKey
**Проблема:** ключ с `Date.now()` делает кэш бесполезным.

**Задачи:**
- Генерировать ключ от:
  - `userId`, `projectId`
  - `platform`
  - `hash(sourceContent)`
  - `hash(promptTemplate + brandVoice + options)`
- Использовать стабильный hash (например, sha256).

**Готовый критерий:** одинаковый запрос повторно берётся из кэша.

---

### 2.2 Очистка кэша
**Задачи:**
- Ленивая очистка батчами при вставке (например, раз в N вставок).
- Или cron (если есть инфраструктура).

---

## Этап 3 — Rate limit и защита аккаунтов

### 3.1 Укрепить rate-limit (serverless-friendly)
**Проблема:** in-memory лимит легко обходится несколькими инстансами.

**Задачи (варианты):**
- Вариант A: Redis/Upstash.
- Вариант B: квоты в БД (у вас уже есть планы) + транзакционный decrement.

---

### 3.2 Защита логина от брутфорса
**Задачи:**
- Таблица `LoginAttempt` (email + ip + count + resetAt).
- Задержка/lockout после N попыток.
- Единый текст ошибки, без раскрытия “email exists”.

---

## Этап 4 — API качество и валидация

### 4.1 Zod схемы на входы API
**Задачи:**
- `generate` route: schema для body.
- Ограничить диапазоны:
  - `temperature` (0..2)
  - `maxTokens` (лимиты по плану)
- Нормализовать `platforms` к enum.

---

### 4.2 Единый формат ошибок
**Задачи:**
- Везде отдавать JSON:
  - `{ error: { code, message, details? } }`
- Единая фабрика ошибок `createErrorResponse()`.

---

### 4.3 Ограничение размера запроса
**Задачи:**
- На сервере: проверка максимального размера `sourceContent`/body.
- На фронте: предупреждение/обрезка/подсказка пользователю.

---

## Этап 5 — Observability и приватность

### 5.1 Редакция логов (redaction)
**Проблема:** риск утечки контента (sourceContent/профиль бренда/ответы).

**Задачи:**
- Не логировать:
  - исходный текст
  - промпты
  - ответы
- Логировать только:
  - длины, хэши, platform, userId, requestId, timings, ошибки

---

### 5.2 requestId и корреляция
**Задачи:**
- Генерировать `requestId` на входе в API.
- Пробрасывать в логи, ответы и записи истории.

---

## Этап 6 — Улучшение UX генерации

### 6.1 Streaming
**Задачи:**
- Поддержка stream-ответов для генерации.
- UI прогресс/частичный вывод (особенно для длинных постов).

---

### 6.2 Повторная генерация и версии
**Задачи:**
- Чётко фиксировать версионность:
  - `OutputVersion` всегда создаётся при regenerate
  - метаданные (модель, температура, токены)

---

## Этап 7 — Тесты

### 7.1 Минимальный набор
**Задачи:**
- Unit:
  - formatPrompt + brandVoice insertion
  - finalizeGeneratedContent (validate+sanitize)
  - cacheKey hash
- API:
  - unauthorized
  - чужой projectId
  - превышение лимита
  - invalid platform

---

## Чек-лист готовности к продакшену

- [ ] Один sourceContent в запросе к модели
- [ ] Brand voice вставляется строго по `{brandVoice}`
- [ ] sanitize/validate единообразны
- [ ] Кэш детерминированный и реально работает
- [ ] Rate limit не in-memory (или квоты БД транзакционно)
- [ ] Логин защищён от перебора
- [ ] Единый JSON формат ошибок
- [ ] Логи без утечек текста + requestId
- [ ] Базовые тесты проходят

---

## Рекомендуемый порядок внедрения

1) Этап 1 (качество/правильность)
2) Этап 2 (кэш/токены)
3) Этап 3 (защита)
4) Этап 4 (API качество)
5) Этап 5 (логи)
6) Этап 6 (стриминг/UX)
7) Этап 7 (тесты)

