# План доведения этапа 3 до 100% (STAGE_3_DETAILED_PLAN)

Цель: закрыть все пункты [STAGE_3_DETAILED_PLAN.md](../STAGES/STAGE_3_DETAILED_PLAN.md), которые ещё не выполнены.

---

## Блок 1: OpenAI-клиент и промпты (Неделя 1)

### 1.1 Rate limiting в openai-client
- **План:** День 1-2 — «Добавить retry logic и rate limiting».
- **Сейчас:** retry есть, rate limiting нет.
- **Задачи:**
  - В [lib/ai/openai-client.ts](lib/ai/openai-client.ts) добавить ограничение частоты вызовов (например, минимальный интервал между запросами или счётчик запросов в минуту).
  - Либо документировать, что rate limiting делается на уровне API route (см. блок 4).

### 1.2 Few-shot examples в промптах
- **План:** День 3-4 — «Добавить few-shot examples для повышения качества генерации».
- **Задачи:**
  - В [lib/ai/prompts/linkedin.ts](lib/ai/prompts/linkedin.ts), [twitter.ts](lib/ai/prompts/twitter.ts), [email.ts](lib/ai/prompts/email.ts) добавить 1–2 примера «исходный контент → результат» в системный промпт или в отдельную секцию шаблона.
  - Не менять контракт `formatPrompt` / `getPlatformPromptTemplate`, если примеры вшиты в шаблон.

### 1.3 Система тестирования промптов
- **План:** День 3-4 — «Создать систему тестирования промптов».
- **Задачи:**
  - Добавить скрипт или набор тестов (например, в `__tests__/prompts/`), который для фиксированного `sourceContent` и платформы проверяет: промпт подставляется без ошибок, длина/формат вывода (опционально с моком OpenAI).
  - Либо документировать ручной процесс тестирования промптов (чек-лист + примеры).

---

## Блок 2: UI и страница генерации (Неделя 2)

### 2.1 PlatformSelector в форме создания/редактирования проекта
- **План:** День 8-9 — «Интегрировать с формой создания/редактирования проекта».
- **Задачи:**
  - В [components/projects/project-form.tsx](components/projects/project-form.tsx) заменить текущие чекбоксы выбора платформ на компонент [PlatformSelector](components/ai/platform-selector.tsx) (или переиспользовать его логику/разметку).
  - Сохранить текущую валидацию и формат данных (массив платформ).

### 2.2 Возможность отмены генерации
- **План:** День 10-11 — «Возможность отмены генерации».
- **Задачи:**
  - На странице [app/(dashboard)/projects/[id]/generate/page.tsx](app/(dashboard)/projects/[id]/generate/page.tsx) при вызове `fetch('/api/generate')` использовать `AbortController`.
  - Передавать `signal` в `fetch(..., { signal })`, по кнопке «Cancel» вызывать `controller.abort()`.
  - Обрабатывать `AbortError` на клиенте (сброс loading, сообщение «Generation cancelled»).
  - Учесть, что серверный запрос к OpenAI уже может быть в процессе — отмена приведёт к разрыву соединения; сервер может логировать отмену по разрыву.

---

## Блок 3: Результаты и отображение (Неделя 3)

### 3.1 Компонент GeneratedContentPreview
- **План:** День 12-13 — «Создать компонент GeneratedContentPreview для предварительного просмотра».
- **Задачи:**
  - Создать [components/ai/generated-content-preview.tsx](components/ai/generated-content-preview.tsx): приём `content`, `platform`, опционально `isEdited`, отображение в читаемом виде (как сейчас в табах на странице генерации).
  - Использовать этот компонент на странице генерации в табах результатов и в блоке «Previously Generated Content».

### 3.2 Кнопки перехода к редактированию
- **План:** День 12-13 — «Добавить кнопки для перехода к редактированию (будет использоваться в Этапе 4)».
- **Задачи:**
  - На странице генерации (и при необходимости на странице проекта) добавить кнопки «Edit» рядом с каждым результатом, ведущие на маршрут редактирования (например, `/projects/[id]/edit` или будущий `/projects/[id]/outputs/[outputId]/edit`).
  - Если маршрут редактирования output ещё не реализован (Этап 4), оставить ссылку-заглушку или кнопку, ведущую на общий edit проекта, с комментарием «Stage 4».

### 3.3 Кэширование результатов
- **План:** День 12-13 — «Реализовать систему кэширования результатов».
- **Задачи:**
  - Определить стратегию: кэш по ключу `(projectId, platforms, hash(sourceContent))` на сервере (в памяти или Redis) или только переиспользование уже сохранённых Output в БД при повторном запросе тех же платформ без вызова OpenAI.
  - Реализовать минимальный вариант: перед генерацией проверять, есть ли уже актуальные Output для выбранных платформ и того же проекта; при совпадении опционально возвращать их без вызова AI (или документировать отложенное кэширование).

### 3.4 Метрики использования AI
- **План:** День 12-13 — «Добавить метрики использования AI».
- **Задачи:**
  - Сохранять в БД или в отдельную таблицу/сервис: количество вызовов генерации по пользователю/проекту, успех/неуспех, опционально время выполнения (уже частично есть в `generationMetadata`).
  - Добавить простой способ просмотра (например, в настройках или админке) или только логирование для последующей аналитики.

---

## Блок 4: Безопасность и валидация

### 4.1 Rate limiting для API
- **План:** Безопасность API — «Rate limiting для предотвращения злоупотребления».
- **Задачи:**
  - В [app/api/generate/route.ts](app/api/generate/route.ts) или в middleware добавить ограничение: N запросов на пользователя (или IP) в минуту/час.
  - При превышении возвращать 429 с заголовком `Retry-After` и JSON `{ error: "Too many requests" }`.

### 4.2 Ограничение размера входного контента
- **План:** Валидация — «Ограничение размера входного контента».
- **Задачи:**
  - В [app/api/generate/route.ts](app/api/generate/route.ts) после проверки на пустоту: получить план пользователя (через subscription или по умолчанию `free`), взять `PLAN_LIMITS[plan].maxCharactersPerContent`, проверить `sourceContent.length <= limit`.
  - При превышении возвращать 400 с сообщением о лимите.
  - На странице генерации опционально показывать счётчик символов и предупреждение при приближении к лимиту.

### 4.3 Защита от обхода квот
- **План:** «Защита от попыток обхода квот».
- **Задачи:**
  - Убедиться, что квота проверяется только на сервере (по сессии/userId), клиент не может передать чужой userId.
  - Проверка квот в [lib/services/ai.ts](lib/services/ai.ts) уже по userId из сессии — зафиксировать в комментарии или в документации.

---

## Блок 5: Тестирование

### 5.1 Unit-тесты
- **План:** День 14-15 и раздел «Тестирование».
- **Задачи:**
  - Настроить Jest или Vitest (если ещё нет) в проекте.
  - Тесты для [lib/ai/openai-client.ts](lib/ai/openai-client.ts): мок OpenAI, проверка вызова с правильными параметрами, retry при ошибке.
  - Тесты для [lib/services/ai.ts](lib/services/ai.ts): моки Prisma и `generateContentWithRetry`, проверка `generateForPlatforms` (квота, вызов OpenAI, upsert, logProjectChange).
  - Тесты для [lib/utils/content-validation.ts](lib/utils/content-validation.ts): `validateContentLength`, `sanitizeContent`, `validatePlatformContent`.
  - Тесты для промптов: подстановка плейсхолдеров, отсутствие битых переменных.

### 5.2 Интеграционные тесты
- **Задачи:**
  - Тест POST [app/api/generate/route.ts](app/api/generate/route.ts): с моком сессии и моком AI-сервиса; проверка 401 без сессии, 400 при пустом sourceContent/невалидных platforms, 200 и структуры ответа при успехе.
  - Тест сохранения в БД: вызов сервиса с моком OpenAI, проверка, что в Prisma создаётся/обновляется Output и запись в ProjectHistory.

### 5.3 E2E-тесты
- **Задачи:**
  - E2E (Playwright или Cypress): открытие страницы генерации, выбор платформ, нажатие Generate, ожидание появления результатов (или мок API для стабильности).
  - Опционально: проверка отображения ошибки при невалидных данных.

---

## Блок 6: Документация и мониторинг

### 6.1 Документация API endpoint
- **План:** День 14-15 — «Документировать API endpoint».
- **Задачи:**
  - Описать POST `/api/generate`: тело запроса (projectId, platforms, sourceContent, options?), ответы 200/400/401/404/429/500, примеры запроса и ответа.
  - Разместить в [docs/](docs/) (например, `docs/API.md` или в README этапа 3).

### 6.2 Логирование и метрики (раздел «Мониторинг»)
- **План:** Логирование всех вызовов AI, ошибок, использования квот, времени выполнения.
- **Задачи:**
  - Убедиться, что в [lib/services/ai.ts](lib/services/ai.ts) и в API route логируются: старт/завершение генерации, ошибки, userId, projectId, количество платформ (уже частично есть через Logger).
  - Опционально: запись времени выполнения генерации в `generationMetadata` или в отдельную таблицу для последующего анализа.

### 6.3 Алертинг
- **План:** «Алерты при превышении порогов ошибок, при достижении лимитов API, при аномальном использовании».
- **Задачи:**
  - Минимальный вариант: документировать, какие метрики и логи смотреть для ручного алертинга.
  - Расширенный: интеграция с сервисом алертов (например, Sentry, логи в внешнюю систему) при частых ошибках OpenAI или при росте 5xx.

---

## Блок 7: Опционально / пост-MVP

Эти пункты в плане помечены как будущее или улучшения; для 100% по букве плана их можно учесть минимально или задокументировать как «следующая итерация».

- **I18N:** поддержка разных языков контента и UI — вынести в отдельный бэклог.
- **Резервные механизмы:** резервная модель, кэширование для восстановления — описать в архитектурном документе или бэклоге.
- **Модерация контента перед сохранением:** отметить в документации как возможное расширение.
- **Пул соединений / оптимизация запросов к OpenAI:** оставить на этап оптимизации после стабилизации.

---

## Порядок выполнения (рекомендуемый)

1. **Блок 4** (безопасность и валидация) — rate limiting API, ограничение размера sourceContent, проверка квот. Небольшой объём, высокий эффект.
2. **Блок 2.1 и 3.1** — PlatformSelector в форме проекта, компонент GeneratedContentPreview. Улучшают соответствие плану по UI.
3. **Блок 1.2** — few-shot в промптах. Улучшает качество без смены архитектуры.
4. **Блок 5** — unit и интеграционные тесты; затем при необходимости E2E.
5. **Блок 6.1** — документация API.
6. **Блоки 1.1, 2.2, 3.2, 3.3, 3.4, 6.2, 6.3** — по приоритету продукта: отмена генерации, кэширование, метрики, rate limiting в клиенте, алертинг.

После выполнения блоков 1–6 (кроме опциональных пунктов из блока 7) этап 3 можно считать выполненным на 100% по STAGE_3_DETAILED_PLAN.
